/* autogenerated by Processing revision 1283 on 2022-06-20 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Smart_Car extends PApplet {

//Sketch variables for the cars
Population population;
float carSize;
int numDirections, numCars;
//Sketch variables for the track
float innerRing, outerRing;

 public void setup(){
    /* size commented out by preprocessor */;
    carSize = 20;
    numDirections = 200;
    numCars = 100;
    population = new Population(carSize, numCars, numDirections);
    innerRing = width/5;
    outerRing = width - width/20;
}

 public void draw(){
    //Draw the cars
    background(255);
    if (population.goodToGo()){
        population.drive(innerRing, outerRing);
    }else{
        population.evaluate();
        population.selection(carSize);
    }

    //Draw the rings for the track
    ellipseMode(CENTER);
    noFill();
    ellipse(width/2, height/2, innerRing, innerRing);
    ellipse(width/2, height/2, outerRing, outerRing);
}
public class Car{
    //Variables for the car
    PVector pos, vel, acc;
    boolean crashed, completed = false;
    float size, fitness;
    int step = 0;
    Directions directions;
    int total;
    int collected = 1;
    PVector[] checkpoints;
    
    //Constructor without directions
    Car(float s, int i){
        size = s;
        pos = new PVector(width/2, height - height/3);
        vel = new PVector();
        acc = new PVector();
        directions = new Directions(i);
        fitness = 1;
        setupCheckpoints();
    }
    //Constructor with directions supplied
    Car(float s, Directions d){
        size = s;
        pos = new PVector(width/2, height - height/3);
        vel = new PVector();
        acc = new PVector();
        directions = d;
        fitness = 1;
        setupCheckpoints();
    }
    //Functions for the car are listed alphabetically


    //Called by update() of this object. Takes a PVector input and applies it to acc.
     public void applyForce(PVector force){
        acc.add(force);
    }
    //Called by population and makes a score for the car. Will be used for natural selection
     public void calcFitness(){
        if (collected == total){
            fitness = 10000000;
            return;
        }
        PVector goal = new PVector(width/2, height - height/3);
        float d = dist(pos.x, pos.y, goal.x, goal.y);
        fitness = map(d, 1, width, width, 1);
        fitness *= collected;
        if (crashed){
            fitness /= 10;
        }
    }
    //Recieve int as parameter and use it to remake the checkpoints array;
     public void collectCP(int i){
        collected++;
        if (checkpoints.length == 1){
            completed = true;
            return;
        }
        PVector[] newCPs = new PVector[checkpoints.length-1];
        for (int x = 0; x < newCPs.length; x++){
            if (x == i){
                newCPs[x] = checkpoints[checkpoints.length-1];
            }else{
                newCPs[x] = checkpoints[x];
            }
        }
        checkpoints = newCPs;
    }
    //Called by population selection() and returns directions
     public Directions getDirections(){
        return directions;
    }
    //Returns fitness
     public float getFitness(){
        return fitness;
    }
    //Parameter supplied by Population in evaluate() and used to normalize fitness based on the best scoring car
     public void normFitness(float m){
        fitness /= m;
    }
    //Setup the checkpoints that will be used for scoring
     public void setupCheckpoints(){
        total = 8;
        checkpoints = new PVector[7];
        checkpoints[0] = new PVector(width/3, height/2);
        checkpoints[1] = new PVector(width/2, height/3);
        checkpoints[2] = new PVector(width - width/3, height/2);
        checkpoints[3] = new PVector(width/3, height-height/3);
        checkpoints[4] = new PVector(width/3, height/3);
        checkpoints[5] = new PVector(width-width/3, height/3);
        checkpoints[6] = new PVector(width-width/3, height - height/3);
    }
    //Called by population and moves the car
     public void update(float i, float o){
        //Only move if the car isn't crashed or completed with its directions
        if (completed || crashed){
            return;
        }
        //Use parameters to check if car has crashed.
        //If car's pos is closer to the center of the course than the inner ring or farther than the outer ring, we've crashed.
        if (dist(width/2, height/2, pos.x, pos.y) < i/2 || dist(width/2, height/2, pos.x, pos.y) > o/2){
            crashed = true;
            return;
        }
        //Check to see if we are out of directions
        if (directions.isOutOfDirections()){
            completed = true;
            return;
        }
        //See if we've collected a checkpoint
        for (int c = checkpoints.length-1; c >= 0; c--){
            if (dist(pos.x, pos.y, checkpoints[c].x, checkpoints[c].y) < size *3){
                collectCP(c);
                break;
            }
        }
        applyForce(directions.getNextDirection(step));
        vel.add(acc);
        pos.add(vel);
        acc.mult(0);
        step++;
    }
    //Called by population and draws the car
     public void show(){
        push();
        translate(pos.x, pos.y);
        rotate(vel.heading() - radians(90));
        fill(150);
        triangle(0, size * 2.5f, -size/2, size, size/2, size);
        pop();
    }
    //Called by population and returns true if car is NOT crashed or completed
     public boolean stillGoing(){
        return !completed && !crashed;
    }
}
public class Directions{
    //Variables for directions
    PVector[] list;
    boolean outOfDirections = false;
    //Constructor without PVectors supplied. Takes an int to let us know how many directions to generate.
    Directions(int n){
        list = new PVector[n];
        for (int i = 0; i < n; i++){
            list[i] = PVector.random2D();
        }
    }
    //COnstructor with PVectors supplied
    Directions(PVector[] l){
        list = l;
    }
    //Functions for directions listed alphabetically

    //called by population selection() and uses the Directions parameter to mix/match PVectors from this list and parameter's list
     public Directions crossover(Directions partner){
        PVector[] newInstructions = new PVector[list.length];
        int mid = floor(random(list.length));
        for (int i = 0; i < list.length; i++){
            if (i > mid){
                newInstructions[i] = list[i];
            }else{
                newInstructions[i] = partner.list[i];
            }
        }
        return new Directions(newInstructions);
    }
    //Takes an int and returns the PVector at that index
     public PVector getNextDirection(int i){
        if (i == list.length-1){
            outOfDirections = true;
        }
        return list[i];
    }
    //Called by the car to see if it can keep going.
     public boolean isOutOfDirections(){
        return outOfDirections;
    }
    //Chance to make a random PVector so that we don't get stuck repeating the same thing forever
     public void mutation(){
        for (int i = 0; i < list.length; i++){
            if (random(1) < 0.01f){
                list[i] = PVector.random2D();
            }
        }
    }
}
public class Population{
    //variables for the population
    Car[] cars;
    ArrayList<Car> matingPool;
    boolean done = false;
    Population(float cs, int cn, int dn){
        cars = new Car[cn];
        for (int i = 0; i < cn; i++){
            cars[i] = new Car(cs, dn);
        }
        matingPool = new ArrayList<Car>();
    }
    //functions for population listed alphabetically

    //Draws the cars and moves them. Also checks if all cars are finished. Learns and tries again afterwards.
     public void drive(float i, float o){
        boolean finished = true;
        for (Car c : cars){
            c.update(i, o);
            c.show();
            if (c.stillGoing()){
                finished = false;
            }
        }
        if (finished){
            done = true;
        }
    }
    //Called by main sketch. Normalized all cars based on their score and asigns them their score
     public void evaluate(){
        float maxFit = 1;
        //Find the highest scoring car
        for (Car c : cars){
            c.calcFitness();
            if (c.getFitness() > maxFit){
                maxFit = c.getFitness();
            }
        }
        //normalize all car scores
        for (Car c : cars){
            c.normFitness(maxFit);
        }
        //reset matingPool and populate the pool based on cars score. Best score gets its name in the hat more times.
        matingPool.clear();
        for (int i = 0; i < cars.length; i++){
            int n = floor(cars[i].getFitness() * 100);
            for (int j = 0; j < n; j++){
                matingPool.add(cars[i]);
            }
        }
    }
    //CHeck if every car is still driving
     public boolean goodToGo(){
        return !done;
    }
    //It's time for natural selection
     public void selection(float cs){
        Car[] newCars = new Car[cars.length];
        for (int i = 0; i < cars.length; i++){
            Directions parentA = matingPool.get(floor(random(matingPool.size()))).getDirections();
            Directions parentB = matingPool.get(floor(random(matingPool.size()))).getDirections();
            Directions child = parentA.crossover(parentB);
            child.mutation();
            newCars[i] = new Car(cs, child);
        }
        cars = newCars;
        done = false;
    }
}


  public void settings() { size(600, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Smart_Car" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
